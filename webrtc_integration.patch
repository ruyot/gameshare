diff --git a/src/signaling.rs b/src/signaling.rs
index 9d2c9fc..5af5c3e 100644
--- a/src/signaling.rs
+++ b/src/signaling.rs
@@
-use futures_util::{SinkExt, StreamExt};
+use futures_util::StreamExt;
 
-use crate::error::GameShareError;
-use crate::host_session::HostSessionManager;
+use crate::{
+    error::GameShareError,
+    host_session::HostSessionManager,
+    webrtc_helper::{Message, Negotiator},
+    ws_signaler::WsSignaler,
+};
+
+use tokio::sync::Mutex;
 
@@
 async fn handle_client(ws: WebSocket, sessions: Sessions, host_mgr: Arc<HostSessionManager>) {
-    let (ws_tx, mut ws_rx) = ws.split();
-    let (tx, mut rx) = mpsc::unbounded_channel::<SignalingMessage>();
-
-    // old writer task → SignalingMessage JSON
-    let ws_tx = Arc::new(tokio::sync::Mutex::new(ws_tx));
-    let ws_tx_clone = ws_tx.clone();
-    tokio::spawn(async move {
-        while let Some(msg) = rx.recv().await {
-            if let Ok(json) = serde_json::to_string(&msg) {
-                let mut ws_tx = ws_tx_clone.lock().await;
-                if let Err(e) = ws_tx.send(Message::text(json)).await {
-                    error!("Failed to send WebSocket message: {}", e);
-                    break;
-                }
-            }
-        }
-    });
+    // split websocket
+    let (mut ws_writer, mut ws_reader) = ws.split();
+
+    // generic channels for webrtc_helper::Message
+    let (to_peer_tx,  mut to_peer_rx)  = mpsc::unbounded_channel::<Message>();
+    let (from_peer_tx, from_peer_rx)   = mpsc::unbounded_channel::<Message>();
+
+    // share session-id once we know it (after Join)
+    let session_id_cell: Arc<Mutex<Option<String>>> = Arc::new(Mutex::new(None));
+    let sid_clone_for_writer = session_id_cell.clone();
+
+    // writer task: Message ➜ SignalingMessage ➜ JSON ➜ websocket
+    tokio::spawn(async move {
+        while let Some(msg) = to_peer_rx.recv().await {
+            if let Some(sid) = &*sid_clone_for_writer.lock().await {
+                let sm = WsSignaler::to_old(&msg, sid);
+                if let Ok(txt) = serde_json::to_string(&sm) {
+                    // ignore closed-socket errors (break loop)
+                    if ws_writer.send(warp::ws::Message::text(txt)).await.is_err() { break; }
+                }
+            }
+        }
+    });
+
+    // reader task: JSON ➜ SignalingMessage ➜ Message
+    let to_new_sender = from_peer_tx.clone();
+    tokio::spawn(async move {
+        while let Some(Ok(frame)) = ws_reader.next().await {
+            if let Ok(text) = frame.to_str() {
+                if let Ok(sm) = serde_json::from_str::<SignalingMessage>(text) {
+                    if let Some(new) = WsSignaler::to_new(&sm) {
+                        let _ = to_new_sender.send(new);
+                    }
+                }
+            }
+        }
+    });
+
+    // wrap channels in WsSignaler for Negotiator
+    let signaler = Arc::new(WsSignaler::new(from_peer_rx, to_peer_tx));
 
-    let mut current_session_id: Option<String> = None;
-    let mut client_type: Option<ClientType> = None;
+    let mut current_session_id: Option<String> = None;
+    let mut client_type:        Option<ClientType> = None;
 
@@
                 ClientType::Host => {
@@ (unchanged)
-                ClientType::Client => {
-                    session.client_senders.push(tx.clone());
-                    info!("Client joined session: {} (total clients: {})", session_id, session.client_senders.len());
-
-                    #[cfg(target_os="linux")]
-                    {
-                        let streamer = host_mgr.get_or_create(&session_id).await?;
-                        let offer_sdp = streamer.create_offer().await?;
-                        let _ = tx.send(SignalingMessage::Offer { sdp: offer_sdp, session_id: session_id.clone() });
-                    }
-                }
+                ClientType::Client => {
+                    // save sid for writer
+                    *session_id_cell.lock().await = Some(session_id.clone());
+
+                    #[cfg(target_os="linux")]
+                    {
+                        // create/get streamer => we already push offer ourselves
+                        let streamer = host_mgr.get_or_create(&session_id).await?;
+                        let pc       = streamer.peer_connection().clone();
+
+                        // forward host-side ICE candidates to the browser
+                        {
+                            let sig = signaler.clone();
+                            let sid = session_id.clone();
+                            pc.on_ice_candidate(Box::new(move |cand| {
+                                let sig = sig.clone();
+                                let sid = sid.clone();
+                                Box::pin(async move {
+                                    if let Some(c) = cand {
+                                        let _ = sig.send(
+                                            Message::IceCandidate {
+                                                candidate: c.candidate,
+                                                sdp_mid:   c.sdp_mid,
+                                                sdp_mline_index: c.sdp_mline_index,
+                                            }
+                                        ).await;
+                                    }
+                                })
+                            }));
+                        }

                        // spin negotiator
                        tokio::spawn(async move {
                            let mut nego = Negotiator::new(pc, signaler, false);
                            while let Ok(msg) = nego.signaler.recv().await {
                                if let Err(e) = nego.handle_remote_message(msg).await {
                                    error!("negotiation failed: {e}");
                                    break;
                                }
                            }
                        });
                    }
                }
            }
        }